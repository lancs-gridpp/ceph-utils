#!/usr/bin/env python3
# 
# Copyright (c) 2025 Lancaster University
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# Written by: Gerard Hand
#
# --------------------------------------------------------------------------------------------------------
# 
# Ceph OSD Bottleneck Analyzer to analyze a list of OSDs and identify potential bottlenecks in a Ceph cluster.
#
# - Host concentration detection
# - Rack distribution analysis
# - PG overlap identification
# - Device class checking
# - Shared disk detection
# - Severity-based reporting
# - Compatible with Python 3.6.8+
#
# Usage: bosttleneck <osd1> <osd2> <osd3> ...


import json
import subprocess
import sys
from collections import defaultdict, Counter

class CephOSDAnalyzer:
    def __init__(self, osd_list):
        self.osd_list = osd_list
        self.osd_metadata = {}
        self.osd_tree = {}
        self.pg_data = {}
        self.bottlenecks = []
        
    def run_ceph_command(self, cmd):
        """Execute a ceph command and return JSON output.

        Args:
            cmd: List of command arguments, e.g. ['ceph', 'osd', 'metadata', '1']

        Returns 
            dict: parsed JSON output or empty dict on error.

        Raises:
            subprocess.CalledProcessError on command failure.
            json.JSONDecodeError on JSON parsing failure.
        """
        try:
            result = subprocess.run(
                cmd + ['--format', 'json'],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                universal_newlines=True,
                check=True
            )
            return json.loads(result.stdout)
        except subprocess.CalledProcessError as e:
            print("Error executing command {}: {}".format(' '.join(cmd), e), file=sys.stderr)
            return {}
        except json.JSONDecodeError as e:
            print("Error parsing JSON output: {}".format(e), file=sys.stderr)
            return {}
    
    def get_osd_metadata(self):
        """Collect metadata for all OSDs."""
        print("Reading OSD metadata...")
        for osd_id in self.osd_list:
            metadata = self.run_ceph_command(['ceph', 'osd', 'metadata', str(osd_id)])
            if metadata:
                self.osd_metadata[osd_id] = metadata
    
    def get_osd_tree(self):
        """Get the OSD tree structure."""
        print("Reading OSD tree...")
        self.osd_tree = self.run_ceph_command(['ceph', 'osd', 'tree'])
    
    def get_pg_data(self):
        """Get PG mapping data."""
        print("Reading PG data...")
        pg_dump = self.run_ceph_command(['ceph', 'pg', 'dump'])
        if 'pg_stats' in pg_dump:
            for pg in pg_dump['pg_stats']:
                pgid = pg['pgid']
                acting = pg.get('acting', [])
                up = pg.get('up', [])
                self.pg_data[pgid] = {
                    'acting': acting,
                    'up': up,
                    'state': pg.get('state', '')
                }
    
    def analyze_host_distribution(self):
        """Check if OSDs are concentrated on few hosts."""
        host_map = defaultdict(list)
        
        for osd_id in self.osd_list:
            if osd_id in self.osd_metadata:
                hostname = self.osd_metadata[osd_id].get('hostname', 'unknown')
                host_map[hostname].append(osd_id)
        
        # Check for concentration
        total_osds = len(self.osd_list)
        for hostname, osds in host_map.items():
            percentage = (len(osds) / total_osds) * 100
            if percentage > 30:  # More than 30% on one host
                self.bottlenecks.append({
                    'type': 'HOST_CONCENTRATION',
                    'severity': 'HIGH' if percentage > 50 else 'MEDIUM',
                    'description': "{} OSDs ({:.1f}%) are on host '{}'".format(len(osds), percentage, hostname),
                    'details': {'hostname': hostname, 'osds': osds, 'percentage': percentage}
                })
        
        return host_map
    
    def analyze_rack_distribution(self):
        """Check if OSDs are in the same rack."""
        if not self.osd_tree or 'nodes' not in self.osd_tree:
            return
        
        rack_map = defaultdict(list)
        osd_to_rack = {}
        
        # Build rack mapping
        for node in self.osd_tree.get('nodes', []):
            if node['type'] == 'rack':
                rack_name = node['name']
                for child_id in node.get('children', []):
                    # Find OSDs under this rack
                    for child_node in self.osd_tree.get('nodes', []):
                        if child_node['id'] == child_id:
                            if child_node['type'] == 'host':
                                for osd_id in child_node.get('children', []):
                                    if osd_id >= 0:  # Negative IDs are buckets
                                        osd_to_rack[osd_id] = rack_name
        
        for osd_id in self.osd_list:
            if osd_id in osd_to_rack:
                rack_map[osd_to_rack[osd_id]].append(osd_id)
        
        # Check for concentration
        total_osds = len(self.osd_list)
        for rack_name, osds in rack_map.items():
            percentage = (len(osds) / total_osds) * 100
            if percentage > 40:
                self.bottlenecks.append({
                    'type': 'RACK_CONCENTRATION',
                    'severity': 'HIGH' if percentage > 60 else 'LOW',
                    'description': "{} OSDs ({:.1f}%) are in rack '{}'".format(len(osds), percentage, rack_name),
                    'details': {'rack': rack_name, 'osds': osds, 'percentage': percentage}
                })
    
    def analyze_pg_overlap(self):
        """Identify PGs that contain multiple OSDs from the list."""
        pg_overlap = defaultdict(list)
        
        for pgid, pg_info in self.pg_data.items():
            acting_osds = pg_info['acting']
            overlap = [osd for osd in acting_osds if osd in self.osd_list]
            
            if len(overlap) > 1:
                pg_overlap[pgid] = {
                    'osds': overlap,
                    'count': len(overlap),
                    'state': pg_info['state']
                }
        
        if pg_overlap:
            total_affected_pgs = len(pg_overlap)
            max_overlap = max(pg['count'] for pg in pg_overlap.values())
            
            severity = 'HIGH' if max_overlap > 2 else 'MEDIUM'
            self.bottlenecks.append({
                'type': 'PG_OVERLAP',
                'severity': severity,
                'description': "{} PGs contain multiple OSDs from the list (max {} OSDs per PG)".format(total_affected_pgs, max_overlap),
                'details': {
                    'affected_pgs': total_affected_pgs,
                    'max_overlap': max_overlap,
                    'sample_pgs': dict(list(pg_overlap.items())[:5])  # Show first 5
                }
            })
        
        return pg_overlap
    
    def analyze_device_class(self):
        """Check if all OSDs are of the same device class."""
        device_classes = Counter()
        
        for osd_id in self.osd_list:
            if osd_id in self.osd_metadata:
                device_class = self.osd_metadata[osd_id].get('device_class', 'unknown')
                device_classes[device_class] += 1
        
        if len(device_classes) == 1:
            device_class = list(device_classes.keys())[0]
            self.bottlenecks.append({
                'type': 'DEVICE_CLASS',
                'severity': 'INFO',
                'description': "All OSDs are of device class '{}'".format(device_class),
                'details': {'device_class': device_class}
            })
    
    def analyze_disk_backend(self):
        """Check if OSDs share the same backing disk."""
        disk_map = defaultdict(list)
        
        for osd_id in self.osd_list:
            if osd_id in self.osd_metadata:
                # Check for backing device
                backend = self.osd_metadata[osd_id].get('backend_filestore_dev_node', 
                         self.osd_metadata[osd_id].get('bluestore_bdev_dev_node', 'unknown'))
                disk_map[backend].append(osd_id)
        
        # Check for OSDs sharing disks
        for disk, osds in disk_map.items():
            if len(osds) > 1 and disk != 'unknown':
                self.bottlenecks.append({
                    'type': 'SHARED_DISK',
                    'severity': 'HIGH',
                    'description': "{} OSDs share the same backing disk: {}".format(len(osds), disk),
                    'details': {'disk': disk, 'osds': osds}
                })
    
    def analyze_network_interface(self):
        """Check if OSDs share network characteristics."""
        # For now, we check if they're on the same host and assume a shared network
        # TODO: Implement network interface analysis
        pass
    
    def analyze(self):
        print("Analyzing OSDs: {}".format(self.osd_list))

        # Grab the necessary data        
        self.get_osd_metadata()
        self.get_osd_tree()
        self.get_pg_data()
        
        # Find things the osds have in common
        self.analyze_host_distribution()
        self.analyze_rack_distribution()
        self.analyze_pg_overlap()
        self.analyze_device_class()
        self.analyze_disk_backend()
        
        # Output the results
        self.print_report()
    
    def print_report(self):
        """Print the analysis report."""
        print("\n" + "="*60)
        print("BOTTLENECK REPORT")
        print("="*60 + "\n")
        
        if not self.bottlenecks:
            print("âœ“ No significant bottlenecks detected!\n")
            return
        
        # Sort by severity
        severity_order = {'HIGH': 0, 'MEDIUM': 1, 'LOW': 2, 'INFO': 3}
        sorted_bottlenecks = sorted(
            self.bottlenecks, 
            key=lambda x: severity_order.get(x['severity'], 99)
        )
        
        for i, bottleneck in enumerate(sorted_bottlenecks, 1):
            severity_icon = {
                'HIGH': 'ðŸ”´',
                'MEDIUM': 'ðŸŸ¡',
                'LOW': 'ðŸŸ¢',
                'INFO': 'â„¹ï¸'
            }.get(bottleneck['severity'], 'â€¢')
            
            print("{}. {} [{}] {}".format(i, severity_icon, bottleneck['severity'], bottleneck['type']))
            print("   {}".format(bottleneck['description']))
            
            if bottleneck.get('details'):
                print("   Details:")
                for key, value in bottleneck['details'].items():
                    if isinstance(value, list) and len(value) > 5:
                        print("     {}: {} ... (showing first 5)".format(key, value[:5]))
                    elif isinstance(value, dict) and len(str(value)) > 100:
                        print("     {}: {} ...".format(key, str(value)[:100]))
                    else:
                        print("     {}: {}".format(key, value))
            print()
        
        # Summary
        high_severity = sum(1 for b in self.bottlenecks if b['severity'] == 'HIGH')
        medium_severity = sum(1 for b in self.bottlenecks if b['severity'] == 'MEDIUM')
        
        print("="*60)
        print("SUMMARY: {} potential bottleneck(s) identified".format(len(self.bottlenecks)))
        if high_severity:
            print("  - {} HIGH severity issue(s) - immediate attention recommended".format(high_severity))
        if medium_severity:
            print("  - {} MEDIUM severity issue(s) - investigation recommended".format(medium_severity))
        print("="*60 + "\n")


def main():
    if len(sys.argv) < 2:
        print("Usage: bottleneck <osd1> <osd2> <osd3> ...")
        print("Example: bottleneck 1 5 12 15")
        sys.exit(1)
    
    try:
        osd_list = [int(osd) for osd in sys.argv[1:]]
    except ValueError:
        print("Error: All arguments must be valid OSD numbers", file=sys.stderr)
        sys.exit(2)
    
    analyzer = CephOSDAnalyzer(osd_list)
    analyzer.analyze()


if __name__ == "__main__":
    main()